---
id: agent-types
slug: /agent-types
sidebar_label: Agent Types
sidebar_position: 4
---

# Agent Types - APM v0.5

APM employs four distinct Agent types, each with clear responsibilities and carefully scoped context. These are functional specializations that leverage LLM expert capabilities through targeted task assignments and scoped context rather than artificial personas.

## Agent Specialization Architecture

APM achieves specialization through **Context Scoping**. Instead of relying on prompt engineering to create "characters," APM provides each Agent with only the files and instructions relevant to their specific role.

* **Setup Agent:** Sees the entire project vision, requirements and constraints.
* **Manager Agent:** Sees the plan and progress logs but does not get into implementation details.
* **Implementation Agent:** Sees assigned tasks and dependency context in great detail but no broad project history.
* **Ad-Hoc Agent:** Sees whatever the calling Agent and/or the User wants them to see.

### Quick Agent Comparison

| Agent Type | Role | Context Scope | Active Phase |
| :--- | :--- | :--- | :--- |
| **Setup Agent** | **Architect** | Project requirements, PRDs - **full project vision** | Project Start Only |
| **Manager Agent** | **Coordinator** | Implementation Plan, Task Assingments, Memory Logs - **big picture** | Entire Project |
| **Implementation Agent** | **Builder** | Specific Task Assignment, Context Dependency Outputs - **tight scope** | As Assigned |
| **Ad-Hoc Agent** | **Specialist** | Isolated context-heavy tasks - **only what the calling Agent provides** | Temporary / As Needed |

---

## 1. Setup Agent

**Role:** The Session Architect.

**Operational Context:** Fresh session. No prior project history.

The Setup Agent is a temporary instance that exists solely to translate user requirements into a structured Implementation Plan. It operates through mandatory progression gates to ensure no step is skipped and no detail is overlooked.

### Core Responsibilities
1.  **Context Synthesis:** systematically interviews the user to gather technical, functional, and process requirements.
2.  **Project Breakdown:** Analyzes the requirements to create a domain-driven task list (Frontend, Backend, DevOps).
3.  **Plan Generation:** Transforms the raw task list into the detailed **APM Implementation Plan artifact**.
4.  **Bootstrap Creation:** Generates the **Bootstrap Prompt** to pass project context to the Manager Agent.

---

## 2. Manager Agent

**Role:** The Project Orchestrator.

**Operational Context:** Maintains the "Big Picture" via the Implementation Plan and Memory System.

The Manager Agent is the central authority. It generally does not write code itself, except when specifically instructed; its main function is to orchestrate the workflow. It is responsible for decision-making, quality assurance, and maintaining the project state.

### Core Responsibilities
1.  **Orchestration:** Selects the next logical task from the Implementation Plan.
2.  **Task Assignment:** Generates precise **Task Assignment Prompts**, injecting necessary context from dependencies if needed (e.g., "Read the API schema generated by the Backend Agent").
3.  **Review:** Analyzes **Memory Logs** from Implementation Agents to verify task completion against acceptance criteria. Issues follow-up prompts on partial completions.
4.  **Plan Maintenance:** Updates the Implementation Plan if new requirements or blockers emerge during execution.

---

## 3. Implementation Agents

**Role:** The Developer.

**Operational Context:** Highly focused. Receives only the context necessary for the current task. Accumulates context as tasks are assigned.

Implementation Agents are the workhorses. A project typically has multiple specialized instances (e.g., `Agent_Frontend`, `Agent_Backend`). They execute tasks like producing code, doing research, testing etc.

### Core Responsibilities
1.  **Execution:** Performs work based strictly on the **Task Assignment Prompt** and User instructions.
2.  **Context Dependency Integration:** Explicitly reads outputs from other Agents (as instructed by the Manager) to ensure compatibility.
3.  **Memory Logging:** Documents execution outputs, file changes, and technical decisions in a standardized **Memory Log**.
4.  **Error Escalation:** If a task gets blocked, Imlpementation Agents generate a **Delegation Prompt** for an Ad-Hoc Agent instead of spiraling into debugging loops. This keeps their context intact and enables more efficient and focused task executions.

### Execution Patterns
* **Single-Step:** For atomic tasks (e.g., "Create a utility function"). executed and logged in one response.
* **Multi-Step:** For complex logic. Executed iteratively with User confirmation at each step to prevent context drift. Users may request multiple steps to be combined for greater token efficiency, but this can lead to reduced output quality.

---

## 4. Ad-Hoc Agents

**Role:** The Temporary Specialist - aka "The Intern".

**Operational Context:** Isolated. Created for a single specific purpose and discarded afterwards. Just like in real life.

Ad-Hoc Agents are "disposable" instances used to solve specific problems without polluting the context of long-running Agents. Implementation Agents typically offload context-heavy work to Ad-Hoc Agents, pausing their own progress, or shifting focus to something else while they wait until the Ad-Hoc Agent returns the necessary results.

### Core Responsibilities
* **Isolation:** Ensures that the extensive context required to solve a bug (e.g., reading 50 library files) does not clog the memory of the main builders. Current official Ad-Hoc delegation workflows include:
  * **Debugging**: analyzing complex error logs or stack traces that would overwhelm an Implementation Agent's context
  * **Research**: investigating documentation or libraries to answer a specific technical question

### Workflow
1.  **Delegate:** The Implementation Agent assigns a specific task to an Ad-Hoc Agent -either following instructions in the Task Assignment Prompt or upon encountering a blocker- by issuing a **Delegation Prompt**.
2.  **Initialize:** User opens a temporary chat, initializes an Ad-Hoc Agent instance and pastes the Delegation Prompt.
3.  **Solve:** Ad-Hoc Agent executes the delegated work in collaboration with the User.
4.  **Deliver:** Agent provides a clean summary of their findigns in a Markdown code block to be pasted back into the calling Agent's session.
5.  **Terminate:** User returns to the calling Agent with the findigns and the Ad-Hoc session is closed.

---

**Next Steps:**
* Learn how to select the right model for each Agent in [Token Consumption Tips](Token_Consumption_Tips.md).
* See how Context Scoping works in [Context and Prompt Engineering](Context_and_Prompt_Engineering.md).
* Customize Agent behaviors in [Modifying APM](Modifying_APM.md).